# Racc::Parser Class Reference

Complete API reference for the `Racc::Parser` class and generated parser classes.

## Overview

All parsers generated by Racc inherit from the `Racc::Parser` class. This class provides methods for parsing, error handling, and debugging. You can override these methods to customize parser behavior.

## Class Hierarchy

```
Object
  └─ Racc::Parser
       └─ YourGeneratedParser
```

## Reserved Names

To avoid conflicts with internal Racc mechanisms:

- Constants: Do not use constants with the `Racc_` prefix
- Methods: Do not use methods with the `racc_` or `_racc_` prefixes

Using these reserved names will cause the parser to malfunction.

## Instance Methods

### Parsing Entry Points

#### `do_parse` -> Object

Starts the parsing process. Calls `next_token` to obtain tokens.

Usage:

```ruby
def parse
  @tokens = [
    [:NUMBER, 1],
    [:PLUS, '+'],
    [:NUMBER, 2],
    [false, '$']
  ]
  do_parse
end

def next_token
  @tokens.shift
end
```

Returns: The result value (typically from the start rule's action)

Requires: You must implement the `next_token` method

See also: [`next_token`](#next_token--symbol-object)

#### `yyparse(receiver, method_id)` -> Object

Starts parsing. Calls `receiver.send(method_id)` to obtain tokens via `yield`.

Parameters:
- `receiver`: Object that will supply tokens
- `method_id`: Method name (symbol or string) to call on receiver

Usage:

```ruby
def parse(scanner)
  yyparse(scanner, :scan)
end

# In scanner:
def scan
  until end_of_input
    # ...
    yield [:NUMBER, 42]
    yield [:PLUS, '+']
    # ...
  end
  yield [false, '$']  # End marker - yield only once
end
```

Important notes:
- The receiver's method must `yield` tokens in the form `[symbol, value]`
- The method is called when the parser first needs a token (parsing is already in progress)
- Don't initialize action variables at the start of the method
- After yielding `[false, anything]`, don't yield again - an exception will occur
- The receiver method must always yield tokens, never return them

### Token Handling

#### `next_token` -> [Symbol, Object]

[Abstract method - must be implemented by user]

Called by the parser to obtain the next token. Must return a two-element array: `[symbol, value]`.

Return value format:
- `[symbol, value]`: The next token
- `[false, anything]` or `nil`: End of input

Token symbol format:

By default:
- Unquoted symbols in grammar (ATOM, NUMBER, etc.) -> Ruby symbols (`:ATOM`, `:NUMBER`)
- Quoted strings in grammar (`'='`, `'+'`, etc.) -> Same string (`'='`, `'+'`)

These defaults can be changed with the `convert` block in the grammar file.

Example:

```ruby
def next_token
  return [false, '$'] if @position >= @tokens.length
  token = @tokens[@position]
  @position += 1
  token
end
```

Raises: `NotImplementedError` if not implemented when using `do_parse`

### Error Handling

#### `on_error(error_token_id, error_value, value_stack)`

Called by the parser core when a syntax error is detected (equivalent to yacc's `yyerror`).

Parameters:
- `error_token_id`: Integer - Internal representation of the error token
- `error_value`: The value of the error token
- `value_stack`: The value stack at the time of error (do not modify!)

Default behavior: Raises `Racc::ParseError`

Usage - Custom error messages:

```ruby
def on_error(token_id, value, value_stack)
  token_name = token_to_str(token_id)
  raise ParseError, "Unexpected #{token_name}: #{value.inspect}"
end
```

Usage - Error recovery:

```ruby
def on_error(token_id, value, value_stack)
  @errors << "Error at #{value}"
  # Return normally to enter error recovery mode
end
```

Notes:
- If this method returns normally, the parser enters error recovery mode
- The value stack must not be modified
- Use `token_to_str` to convert `token_id` to a readable string

#### `token_to_str(token_id)` -> String

Converts a token's internal representation (integer) to its string representation from the grammar file.

Parameters:
- `token_id`: Integer - Internal token ID

Returns: String - Token symbol as it appears in the grammar, or `nil` if out of range

Raises: `TypeError` if `token_id` is not an integer

Example:

```ruby
def on_error(token_id, value, value_stack)
  token_str = token_to_str(token_id)
  puts "Parse error at token: #{token_str}"
end
```

#### `yyerror`

Manually enters error recovery mode. Does not call `on_error`.

Usage:

```ruby
expression: IDENT
  {
    if val[0] == "error"
      yyerror  # Enter error recovery mode
    end
    result = val[0]
  }
```

Important: Only call from within an action. Do not call from outside the parsing process.

#### `yyerrok`

Exits error recovery mode and returns to normal parsing.

Usage:

```ruby
error_recovery: error SEMICOLON
  {
    yyerrok  # Resume normal parsing
    result = :recovered
  }
```

Important: Only call from within an action.

### Flow Control

#### `yyaccept`

Immediately exits `do_parse` or `yyparse`, returning the value at the top of the value stack.

Usage:

```ruby
statement: BREAK
  {
    result = :break
    yyaccept  # Exit parsing immediately
  }
```

Returns: The value currently at the top of the value stack

Important: Only call from within an action.

## Action Variables

These special variables are available within action blocks in your grammar file.

### `result` (yacc's `$$`)

The value of the left-hand side (the result of the rule).

Default value: `val[0]`

Usage:

```ruby
expression: term '+' term
  {
    result = val[0] + val[2]
  }
```

Note: Not available if `options no_result_var` is specified in the grammar.

### `val` (yacc's `$1, $2, $3, ...`)

Array containing the values of right-hand side symbols (zero-indexed).

Usage:

```ruby
expression: term '+' term
  {
    # val[0] = value of first 'term'
    # val[1] = value of '+'
    # val[2] = value of second 'term'
    result = val[0] + val[2]
  }
```

Notes:
- Array is freshly created for each action, so you can freely modify or discard it
- Indexing starts at 0 (unlike yacc's $1, $2, which start at 1)

### `_values` (yacc's `..., $-2, $-1, $0`)

The internal value stack used by the Racc core.

Warning: This is the actual object used by Racc. Do not modify unless you fully understand parser internals. Modifying this stack can cause parser corruption.

Usage: Primarily for inspection/debugging by advanced users.

## Instance Variables

### `@yydebug`

Controls debug output. Set to `true` to enable debugging (parser must be generated with `-g`).

Usage:

```ruby
parser = MyParser.new
parser.instance_variable_set(:@yydebug, true)
result = parser.parse(input)
```

Output: Detailed parsing information to `@racc_debug_out`

Requirements: Parser must be generated with `racc -g`

### `@racc_debug_out`

Output destination for debug messages.

Default: `$stderr`

Usage:

```ruby
parser = MyParser.new
parser.instance_variable_set(:@yydebug, true)
parser.instance_variable_set(:@racc_debug_out, File.open('debug.log', 'w'))
```

## Exceptions

### `Racc::ParseError`

Raised by the default `on_error` implementation when a syntax error occurs.

Inheritance: `StandardError`

Usage - Catching parse errors:

```ruby
begin
  result = parser.parse(input)
rescue Racc::ParseError => e
  puts "Parse error: #{e.message}"
end
```

Usage - Raising custom errors:

```ruby
def on_error(token_id, value, value_stack)
  raise Racc::ParseError, "Unexpected token at line #{@line}"
end
```

## Complete Example

Here's a complete example demonstrating the parser class API:

```ruby
# Generated by: racc calculator.y -o calculator.rb

class Calculator < Racc::Parser
  # ... (Racc-generated code) ...

  # User code (from ---- inner block):

  def parse(input)
    @tokens = tokenize(input)
    @position = 0
    do_parse
  end

  def next_token
    return [false, '$'] if @position >= @tokens.length
    token = @tokens[@position]
    @position += 1
    token
  end

  def tokenize(input)
    # Tokenization logic
    tokens = []
    # ...
    tokens
  end

  def on_error(token_id, value, value_stack)
    token_name = token_to_str(token_id)
    raise ParseError, "Syntax error at #{token_name}: #{value.inspect}"
  end
end

# Usage:
parser = Calculator.new
result = parser.parse("2 + 3 * 4")
puts result  # => 14
```

## Advanced Usage

### Custom Parser Base Class

You can specify a custom base class in the grammar file:

```ruby
class MyParser < CustomBase
rule
  # ...
end
```

Warning: This significantly affects parser behavior. Only use if you have a specific need.

### Multiple Parsers in One File

Each parser class is independent. You can have multiple parsers:

```ruby
# grammar1.y
class Parser1 < Racc::Parser
  # ...
end

# grammar2.y
class Parser2 < Racc::Parser
  # ...
end

# Use both:
p1 = Parser1.new
p2 = Parser2.new
```

### Thread Safety

Racc parsers maintain state in instance variables during parsing. Each thread should use its own parser instance:

```ruby
# Thread-safe usage:
Thread.new do
  parser = MyParser.new  # New instance per thread
  result = parser.parse(input)
end
```

### Reusing Parser Instances

Parser instances can be reused for multiple parse operations:

```ruby
parser = MyParser.new

result1 = parser.parse(input1)
result2 = parser.parse(input2)  # Safe - parser resets state
```

Note: Ensure your `parse` method properly resets any custom state.

## Debugging Tips

### Enable Debug Output

```ruby
parser = MyParser.new
parser.instance_variable_set(:@yydebug, true)
result = parser.parse(input)
```

### Redirect Debug Output

```ruby
parser.instance_variable_set(:@racc_debug_out, File.open('parse.log', 'w'))
```

### Custom Debugging

```ruby
def on_error(token_id, value, value_stack)
  puts "Error at token: #{token_to_str(token_id)}"
  puts "Current value: #{value.inspect}"
  puts "Stack depth: #{value_stack.length}"
  raise ParseError
end
```

## Yacc Compatibility Reference

For users familiar with yacc/bison:

| yacc/bison | Racc | Notes |
|------------|------|-------|
| `yyparse()` | `do_parse` or `yyparse()` | Two methods available |
| `yylex()` | `next_token` | Returns `[symbol, value]` |
| `yyerror()` | `on_error()` | Takes 3 arguments |
| `YYACCEPT` | `yyaccept` | Method call |
| `YYERROR` | `yyerror` | Method call |
| `yyerrok` | `yyerrok` | Method call |
| `$$` | `result` | Local variable in action |
| `$1, $2, ...` | `val[0], val[1], ...` | Zero-indexed array |
| `$-1, $-2, ...` | `_values[-1], ...` | Don't modify! |
| `%token` | `token` | Optional in Racc |
| `%prec` | `= SYMBOL` | Different syntax |
| `%expect` | `expect` | Same behavior |
