# Debugging Racc Parsers

This guide covers common problems you'll encounter when working with Racc and how to solve them.

## Table of Contents

- [Grammar File Parse Errors](#grammar-file-parse-errors)
- [Shift/Reduce and Reduce/Reduce Conflicts](#shiftreduce-and-reducereduce-conflicts)
- [Parser Generated Successfully but Doesn't Work](#parser-generated-successfully-but-doesnt-work)
- [Token-Related Issues](#token-related-issues)
- [Debugging Tools and Techniques](#debugging-tools-and-techniques)
- [Common Mistakes](#common-mistakes)

## Grammar File Parse Errors

### Symptom

Racc reports a syntax error when processing your grammar file:

```
parse error on value "end" (tEND)
```

### Diagnosis

1. Check the line number in the error message
2. Look for common syntax errors around that line:
  - Unmatched braces `{ }` in actions
  - Missing colons `:` after rule names
  - Unclosed strings or comments
  - Missing `end` keyword

### Solution

#### Unmatched Braces

```ruby
# Wrong:
expression: term '+' term
  {
    result = val[0] + val[2]
  # Missing closing brace!

# Correct:
expression: term '+' term
  {
    result = val[0] + val[2]
  }
```

#### Missing Colon

```ruby
# Wrong:
expression term '+' term

# Correct:
expression: term '+' term
```

#### Block-End Confusion

If the error occurs at a closing brace or `end`, you've likely added an extra opening delimiter somewhere earlier. Count your braces!

### Prevention

- Use an editor with bracket matching
- Properly indent your grammar file
- Comment complex actions to track scope

## Shift/Reduce and Reduce/Reduce Conflicts

### Symptom

Racc reports conflicts after processing your grammar:

```
5 shift/reduce conflicts
1 reduce/reduce conflict
```

### Understanding Conflicts

Shift/Reduce Conflict:
The parser can't decide whether to:
- Shift: Read another token
- Reduce: Apply a rule

Reduce/Reduce Conflict:
The parser can't decide which of two rules to apply.

### Diagnosis

Generate a detailed state machine report:

```bash
racc -v mygrammar.y
```

This creates `mygrammar.output` with detailed conflict information.

Example output:

```
State 23

    15: exp -> exp . '+' exp
    15: exp -> exp '+' exp .
    16: exp -> exp . '*' exp

    '*'    shift, goto 24
    '+'    shift, goto 25
    $end   reduce using rule 15 (exp -> exp '+' exp)

    '*': shift/reduce conflict (shift 24, reduce 15)
```

This shows that when the parser sees `*` after `exp '+' exp`, it doesn't know whether to shift (read the `*`) or reduce (complete the addition).

### Solution

#### 1. Add Operator Precedence

Most arithmetic conflicts are resolved by declaring precedence:

```ruby
class Calculator
  prechigh
    nonassoc UMINUS
    left '*' '/'
    left '+' '-'
  preclow
rule
  exp: exp '+' exp
     | exp '-' exp
     | exp '*' exp
     | exp '/' exp
     | '-' exp = UMINUS
     | NUMBER
end
```

This tells Racc:
- Multiplication has higher precedence than addition
- Addition is left-associative

#### 2. Restructure the Grammar

Sometimes conflicts indicate a structural problem:

```ruby
# Ambiguous - causes conflicts:
statement: IF expr THEN statement
         | IF expr THEN statement ELSE statement

# Better - no conflict:
statement: IF expr THEN statement else_part

else_part: /* empty */
         | ELSE statement
```

#### 3. Use `expect` for Acceptable Conflicts

If you understand the conflict and it's harmless (like the classic dangling-else problem):

```ruby
class MyParser
  expect 1    # Expect exactly 1 shift/reduce conflict
rule
  # ...
end
```

This suppresses warnings as long as there's exactly 1 conflict.

Important:
- This doesn't fix conflicts, it just suppresses warnings
- Only use when you understand why the conflict exists
- Doesn't work for reduce/reduce conflicts

### Learning More

Conflicts are a complex topic. For in-depth understanding, consult:

- "[Compilers: Principles, Techniques, and Tools](https://suif.stanford.edu/dragonbook/)" (Dragon Book)
- "[Ruby を 256 倍使うための本 無道編](https://i.loveruby.net/ja/support/ruby256mudo.html)" by Minero Aoki (Japanese)
- The `.output` file generated by `racc -v`

## Parser Generated Successfully but Doesn't Work

### Symptom

- Parser generates without errors
- But produces wrong results or raises exceptions at runtime

### Debugging with Debug Mode

Generate a parser with debugging code:

```bash
racc -g mygrammar.y -o myparser.rb
```

Enable debugging at runtime:

```ruby
parser = MyParser.new
parser.instance_variable_set(:@yydebug, true)
result = parser.parse(input)
```

Debug output shows:

```
read    :NUMBER (42)
shift   :NUMBER
goto    exp
reduce  exp -> NUMBER
read    :PLUS
shift   :PLUS
read    :NUMBER (3)
shift   :NUMBER
goto    exp
reduce  exp -> exp '+' exp
accept  14
```

This shows exactly what the parser is doing:
- Which tokens are read
- When shifts and reductions occur
- What rules are being applied
- The current state

### Redirect Debug Output

To save debug output to a file:

```ruby
parser = MyParser.new
parser.instance_variable_set(:@yydebug, true)
parser.instance_variable_set(:@racc_debug_out, File.open('debug.log', 'w'))
result = parser.parse(input)
```

### Common Issues Revealed by Debugging

#### Wrong Token Values

```
read    :NUMBER ("42")    # Should be integer!
```

Fix your tokenizer:

```ruby
# Wrong:
tokens << [:NUMBER, text]

# Correct:
tokens << [:NUMBER, text.to_i]
```

#### Wrong Rule Reductions

If the parser reduces the wrong rule, your grammar may be ambiguous or your token sequence incorrect.

#### Value Calculation Errors

Add debug output to your actions:

```ruby
expression: term '+' term
  {
    puts "Adding: #{val[0].inspect} + #{val[2].inspect}"
    result = val[0] + val[2]
  }
```

## Token-Related Issues

### Issue 1: Parser Hangs or Doesn't Recognize End of Input

Symptom: Parser never completes or raises unexpected errors.

Cause: Forgot to send end-of-input marker.

Solution:

Always return `[false, anything]` or `nil` when tokens are exhausted:

```ruby
def next_token
  return [false, '$'] if @position >= @tokens.length
  token = @tokens[@position]
  @position += 1
  token
end
```

Important notes:
- As of Racc 0.10.2+, `next_token` is guaranteed not to be called after returning `[false, anything]`
- Can return `nil` instead of `[false, anything]` (modern Racc versions)

### Issue 2: Wrong Token Format

Symptom: Parser raises exceptions or produces wrong results.

Cause: Tokens not in `[symbol, value]` format.

Wrong:

```ruby
# Returns a hash:
def next_token
  {type: :NUMBER, value: 42}
end

# Returns just the value:
def next_token
  42
end
```

Correct:

```ruby
def next_token
  [:NUMBER, 42]
end
```

### Issue 3: Token Symbol Mismatch

Symptom: Parser doesn't recognize tokens.

Cause: Token symbols from lexer don't match grammar.

Check your grammar:

```ruby
rule
  expression: NUMBER  # Expects :NUMBER symbol
```

Check your lexer:

```ruby
# Must match:
tokens << [:NUMBER, 42]  # Correct

# Won't match:
tokens << [:DIGIT, 42]   # Wrong symbol!
tokens << ["NUMBER", 42] # String, not symbol!
```

## Debugging Tools and Techniques

### Technique 1: State Machine Visualization

Generate detailed state information:

```bash
racc -v grammar.y
less grammar.output
```

Study the state machine to understand parser behavior.

### Technique 2: Incremental Development

Build your grammar incrementally:

1. Start with a minimal grammar
2. Test thoroughly
3. Add one feature at a time
4. Test after each addition

Example progression:

```ruby
# Step 1: Just numbers
rule
  expression: NUMBER
end

# Step 2: Add addition
rule
  expression: expression '+' expression
            | NUMBER
end

# Step 3: Add other operators
rule
  expression: expression '+' expression
            | expression '*' expression
            | NUMBER
end
```

### Technique 3: Unit Test Your Grammar

Write tests for each grammar rule:

```ruby
describe MyParser do
  it "parses numbers" do
    parser = MyParser.new
    expect(parser.parse("42")).to eq(42)
  end

  it "parses addition" do
    parser = MyParser.new
    expect(parser.parse("2+3")).to eq(5)
  end

  it "respects precedence" do
    parser = MyParser.new
    expect(parser.parse("2+3*4")).to eq(14)
  end
end
```

### Technique 4: Print Intermediate Values

Add debug output to actions:

```ruby
expression: term '+' term
  {
    puts "Left: #{val[0].inspect}, Right: #{val[2].inspect}"
    result = val[0] + val[2]
    puts "Result: #{result.inspect}"
  }
```

### Technique 5: Validate Token Stream

Before parsing, inspect your token stream:

```ruby
tokens = lexer.tokenize(input)
pp tokens  # Pretty-print tokens
parser.parse_tokens(tokens)
```

### Technique 6: Check Grammar Syntax Only

Quick validation without generating parser:

```bash
racc -C grammar.y
```

## Common Mistakes

### Mistake 1: Modifying `_values`

Never do this:

```ruby
expression: term
  {
    _values.pop  # DANGER!
    result = val[0]
  }
```

The `_values` stack is internal to Racc. Modifying it corrupts the parser.

### Mistake 2: Off-by-One in `val` Array

Remember: `val` is zero-indexed!

```ruby
expression: term '+' term
  {
    # Wrong (yacc-style, 1-indexed):
    result = $1 + $3

    # Correct (Ruby-style, 0-indexed):
    result = val[0] + val[2]
  }
```

### Mistake 3: Not Handling Whitespace

Symptom: Parser fails on input with spaces.

Cause: Lexer doesn't handle whitespace.

Solution:

```ruby
# In lexer:
when @ss.scan(/\s+/)
  # Ignore whitespace - no token
```

### Mistake 4: Using Reserved Names

Avoid these prefixes:
- Constants: `Racc_*`
- Methods: `racc_*`, `_racc_*`

### Mistake 5: Forgetting End-of-Input

Already covered in [Token-Related Issues](#token-related-issues), but worth repeating: Always send `[false, '$']` when tokens run out!

### Mistake 6: Wrong Action Return Value

When using `options no_result_var`:

```ruby
options no_result_var

rule
  expression: term '+' term
    {
      x = val[0] + val[2]
      # Wrong: No explicit return, x is discarded
    }

  # Correct - last expression is returned:
  expression: term '+' term
    {
      val[0] + val[2]
    }
```

## Debugging Checklist

When your parser misbehaves, work through this checklist:

- [ ] Grammar file syntax is valid (`racc -C`)
- [ ] Understand all conflicts (`racc -v`, read `.output` file)
- [ ] Tokens are in `[symbol, value]` format
- [ ] End-of-input marker `[false, '$']` is sent
- [ ] Token symbols match between lexer and grammar
- [ ] Token values have correct types (e.g., integers not strings)
- [ ] Whitespace is handled by lexer
- [ ] Actions use `val[0]`, `val[1]`, not `$1`, `$2`
- [ ] Not modifying `_values` stack
- [ ] Debug mode enabled (`racc -g`, `@yydebug = true`)
- [ ] Debug output reviewed and understood

## Getting Help

If you're still stuck:

1. Simplify: Reduce your grammar to the smallest case that fails
2. Isolate: Test lexer and parser separately
3. Compare: Look at working examples in the Racc repository
4. Read: The `.output` file often contains the answer
5. Share: Ask for help with a minimal reproducible example

## Advanced Debugging

### Custom Error Messages

Provide better error messages:

```ruby
def on_error(token_id, value, value_stack)
  token_name = token_to_str(token_id)
  line = @lexer.line_number
  column = @lexer.column_number

  raise ParseError, "Syntax error at line #{line}, column #{column}: " \
                    "unexpected #{token_name} (#{value.inspect})"
end
```

### Error Recovery

Implement error recovery with the `error` token:

```ruby
rule
  statements: statement
            | statements statement
            | statements error statement
              {
                puts "Recovered from error"
                yyerrok
              }
end
```

### Performance Debugging

If your parser is slow:

1. Ensure you're not using `-g` debug mode in production
2. Use the C extension (not `-E` embedded mode)
3. Profile your lexer - it's often the bottleneck
4. Consider using `strscan` for tokenization

## Summary

Most Racc debugging falls into these categories:

1. Grammar syntax errors - Check for typos, matched braces
2. Conflicts - Use `-v` to understand, add precedence or restructure
3. Token issues - Verify format `[symbol, value]` and end-of-input
4. Runtime errors - Enable debug mode with `-g` and `@yydebug = true`

The debug output from `racc -g` is your best friend. It shows exactly what the parser is doing and will reveal most problems quickly.
